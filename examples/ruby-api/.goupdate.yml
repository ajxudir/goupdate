# Ruby API - Custom config for Bundler (not in defaults)
# Demonstrates: Adding support for an unsupported package manager
#
# This example shows how to add full goupdate support for Ruby/Bundler
# without waiting for upstream changes. Define your own rules!

rules:
  bundler:
    manager: ruby
    format: raw
    include:
      - "**/Gemfile"
    exclude:
      - "**/vendor/**"

    # Extract gem name and version from Gemfile syntax: gem 'name', '~> version'
    extraction:
      pattern: "(?m)^\\s*gem\\s+['\"](?P<n>[^'\"]+)['\"](?:,\\s*['\"](?P<constraint>[~>=<]+)?\\s*(?P<version>[\\d.]+)['\"])?"

    # Map all gems as prod dependencies (Gemfile doesn't separate by sections for simple parsing)
    fields:
      dependencies: prod

    # Ruby's ~> is the pessimistic operator (similar to npm's ~)
    constraint_mapping:
      "~>": "~"

    groups:
      framework:
        - rails
        - puma
      database:
        - pg
        - redis
      background:
        - sidekiq
      testing:
        - rspec-rails
        - factory_bot_rails

    ignore:
      - rubocop
      - rubocop-rails

    exclude_versions:
      - "(?i)pre"
      - "(?i)alpha"
      - "(?i)beta"

    # Custom command to fetch available versions from RubyGems API
    # Uses grep instead of jq for portability (jq may not be pre-installed)
    outdated:
      commands: |
        curl -s "https://rubygems.org/api/v1/versions/{{package}}.json" |
        grep -oE '"number":"[0-9]+\.[0-9]+(\.[0-9]+)*"' |
        grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)*'
      format: raw
      extraction:
        pattern: "(?P<version>[\\d.]+)"
      timeout_seconds: 30

    # Custom command to update lock file
    update:
      commands: |
        bundle update {{package}} --conservative
      timeout_seconds: 120

# System tests for Ruby/Rails API projects
system_tests:
  run_preflight: true
  run_mode: after_each
  stop_on_fail: true
  tests:
    # Install dependencies
    - name: bundle-install
      commands: bundle install
      timeout_seconds: 300
      continue_on_fail: true  # Skip if bundler not available

    # Start server and verify HTTP 200 response
    - name: http-test
      commands: |
        bundle exec puma -p 9292 &
        SERVER_PID=$!
        sleep 3
        # Check HTTP 200 status and response content
        STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:9292/health)
        BODY=$(curl -s http://localhost:9292/health)
        kill $SERVER_PID 2>/dev/null || true
        # Verify status is 2xx and response contains expected content
        [ "$STATUS" -ge 200 ] && [ "$STATUS" -lt 300 ] || { echo "HTTP status $STATUS != 2xx"; exit 1; }
        echo "$BODY" | grep -q '"status"' || { echo "Response missing status field"; exit 1; }
        echo "HTTP test passed! Status: $STATUS"
      timeout_seconds: 60

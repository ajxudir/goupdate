# GoUpdate - Auto Update Workflow
# Automated dependency updates via PR to staging branch
#
# Triggers:
#   - Schedule (weekly): Check dependencies → Create PR with updates
#   - Manual dispatch: check-only or update mode
#
# Flow:
#   1. Check for dependency updates
#   2. Apply updates and run tests
#   3. Create PR to stage branch
#   4. If AUTO_MERGE_UPDATES is true: wait for checks, merge PR
#      (release workflow triggers automatically on push to stage)
#   5. If AUTO_MERGE_UPDATES is false: leave PR for manual review
#
# Configuration (modify in env section below):
#   - ENABLE_* flags: Enable/disable package managers
#   - *_VERSION: Runtime versions
#   - UPDATE_BRANCH_NAME: Branch name for dependency updates
#   - UPDATE_TARGET_BRANCH: Branch to merge updates into (stage)
#   - AUTO_MERGE_UPDATES: Enable auto-merge for update PRs
#   - PR_TITLE: PR title template (use {date} and {type} placeholders)
#   - COMMIT_MESSAGE: Commit message template
#   - EXCLUDE_PACKAGES: Packages to skip updating

name: GoUpdate - Auto Update

on:
  # Weekly check on Monday at 00:00 UTC
  schedule:
    - cron: '0 0 * * 1'

  # Manual trigger with multiple modes
  workflow_dispatch:
    inputs:
      mode:
        description: 'Operation mode'
        required: true
        default: 'update'
        type: choice
        options:
          - check-only   # Just check for updates, no changes
          - update       # Check + apply updates + create PR
      update-type:
        description: 'Dependency update type'
        required: false
        default: 'minor'
        type: choice
        options:
          - minor
          - patch

# Prevent concurrent runs on same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

# ============================================================================
# CONFIGURATION - Modify for your project
# ============================================================================
env:
  GOUPDATE_REPO: 'ajxudir/goupdate'

  # Package Managers (set to 'true' to enable)
  ENABLE_NPM: 'false'
  ENABLE_YARN: 'false'
  ENABLE_PNPM: 'false'
  ENABLE_COMPOSER: 'false'
  ENABLE_PIP: 'false'
  ENABLE_PIPENV: 'false'
  ENABLE_GO: 'true'
  ENABLE_NUGET: 'false'

  # Runtime Versions
  NODE_VERSION: '20'
  PHP_VERSION: '8.2'
  PYTHON_VERSION: '3.12'
  GO_VERSION: '1.24'
  DOTNET_VERSION: '8.0'

  # Branches
  UPDATE_BRANCH_NAME: 'goupdate/auto-update-minor'
  UPDATE_TARGET_BRANCH: 'stage'

  # Auto-merge
  AUTO_MERGE_UPDATES: 'true'

  # PR title template - use {date} for current date, {type} for update type (minor/patch/all)
  PR_TITLE: 'GoUpdate: Auto update - {type} ({date})'
  # Commit message template - supports {date} and {type} placeholders
  COMMIT_MESSAGE: 'GoUpdate: Auto update - {type} ({date})'
  EXCLUDE_PACKAGES: ''

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  # ============================================================================
  # Prepare - Determine what actions to take based on trigger
  # ============================================================================
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    timeout-minutes: 2
    outputs:
      run-dependency-check: ${{ steps.config.outputs.run_dependency_check }}
      run-updates: ${{ steps.config.outputs.run_updates }}
      check-only: ${{ steps.config.outputs.check_only }}
      update-type: ${{ steps.config.outputs.update_type }}
      auto-merge-updates: ${{ steps.config.outputs.auto_merge_updates }}

    steps:
      - name: Validate GitHub App credentials
        env:
          HAS_APP_ID: ${{ secrets.GOUPDATE_APP_ID != '' }}
          HAS_APP_PRIVATE_KEY: ${{ secrets.GOUPDATE_APP_PRIVATE_KEY != '' }}
        run: |
          if [ "$HAS_APP_ID" != "true" ] || [ "$HAS_APP_PRIVATE_KEY" != "true" ]; then
            echo "::error::GoUpdate: GitHub App credentials required"
            echo ""
            echo "To enable auto-merge, configure these repository secrets:"
            echo "  - GOUPDATE_APP_ID"
            echo "  - GOUPDATE_APP_PRIVATE_KEY"
            echo ""
            echo "See: https://github.com/${{ github.repository }}#github-app-setup"
            exit 1
          fi

      - name: Determine actions
        id: config
        env:
          AUTO_MERGE: ${{ env.AUTO_MERGE_UPDATES }}
        run: |
          EVENT="${{ github.event_name }}"
          MODE="${{ github.event.inputs.mode }}"
          UPDATE_TYPE="${{ github.event.inputs.update-type }}"

          echo "Event: $EVENT, Mode: $MODE, Update-Type: $UPDATE_TYPE, Auto-Merge: $AUTO_MERGE"

          # Pass through auto-merge setting
          echo "auto_merge_updates=$AUTO_MERGE" >> $GITHUB_OUTPUT

          case "$EVENT" in
            schedule)
              echo "run_dependency_check=true" >> $GITHUB_OUTPUT
              echo "run_updates=true" >> $GITHUB_OUTPUT
              echo "check_only=false" >> $GITHUB_OUTPUT
              echo "update_type=minor" >> $GITHUB_OUTPUT
              ;;
            workflow_dispatch)
              case "$MODE" in
                check-only)
                  echo "run_dependency_check=true" >> $GITHUB_OUTPUT
                  echo "run_updates=false" >> $GITHUB_OUTPUT
                  echo "check_only=true" >> $GITHUB_OUTPUT
                  echo "update_type=${UPDATE_TYPE:-minor}" >> $GITHUB_OUTPUT
                  ;;
                update)
                  echo "run_dependency_check=true" >> $GITHUB_OUTPUT
                  echo "run_updates=true" >> $GITHUB_OUTPUT
                  echo "check_only=false" >> $GITHUB_OUTPUT
                  echo "update_type=${UPDATE_TYPE:-minor}" >> $GITHUB_OUTPUT
                  ;;
                *)
                  echo "run_dependency_check=true" >> $GITHUB_OUTPUT
                  echo "run_updates=true" >> $GITHUB_OUTPUT
                  echo "check_only=false" >> $GITHUB_OUTPUT
                  echo "update_type=${UPDATE_TYPE:-minor}" >> $GITHUB_OUTPUT
                  ;;
              esac
              ;;
          esac

  # ============================================================================
  # Check for dependency updates
  # ============================================================================
  check-updates:
    name: Check Updates
    needs: prepare
    if: needs.prepare.outputs.run-dependency-check == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      has-updates: ${{ steps.goupdate.outputs.has-updates }}
      has-major-only: ${{ steps.goupdate.outputs.has-major-only }}
      summary: ${{ steps.goupdate.outputs.summary }}
      major-packages: ${{ steps.goupdate.outputs.major-packages }}
      outdated-output: ${{ steps.goupdate.outputs.outdated-output }}

    steps:
      - name: Checkout main first
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Ensure target branch exists
        uses: ./.github/actions/_git-branch
        with:
          branch: ${{ env.UPDATE_TARGET_BRANCH }}
          base: main
          create-if-missing: 'true'
          push: 'true'

      - name: Setup Go
        uses: ./.github/actions/_go-setup
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install goupdate
        uses: ./.github/actions/_goupdate-install

      - name: Check for updates
        id: goupdate
        uses: ./.github/actions/_goupdate-check
        with:
          exclude-packages: ${{ env.EXCLUDE_PACKAGES }}

      - name: Generate job summary
        env:
          SUMMARY: ${{ steps.goupdate.outputs.summary }}
        run: |
          echo "## GoUpdate - Check Updates" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Update check complete: $SUMMARY" >> $GITHUB_STEP_SUMMARY

      - name: Fail on major-only updates
        if: steps.goupdate.outputs.has-major-only == 'true' && steps.goupdate.outputs.has-updates == 'false'
        env:
          SUMMARY: ${{ steps.goupdate.outputs.summary }}
          MAJOR_PACKAGES: ${{ steps.goupdate.outputs.major-packages }}
        run: |
          echo "::error::GoUpdate: Only major updates available"
          echo ""
          echo "════════════════════════════════════════════════════════════════"
          echo "⚠️  MAJOR UPDATES REQUIRE MANUAL REVIEW"
          echo "════════════════════════════════════════════════════════════════"
          echo ""
          echo "The following packages have only major version updates:"
          echo "$MAJOR_PACKAGES" | tr ' ' '\n' | sed '/^$/d' | sed 's/^/  - /'
          echo ""
          echo "Major updates may contain breaking changes. To resolve:"
          echo "  1. Review changelogs for breaking changes"
          echo "  2. Update packages manually, or"
          echo "  3. Add to EXCLUDE_PACKAGES to skip"
          echo ""
          exit 1

  # ============================================================================
  # Apply updates and create PR
  # ============================================================================
  apply-updates:
    name: Apply Updates
    needs: [prepare, check-updates]
    if: |
      needs.prepare.outputs.run-updates == 'true' &&
      needs.check-updates.outputs.has-updates == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      updated-count: ${{ steps.goupdate.outputs.updated-count }}
      has-changes: ${{ steps.goupdate.outputs.has-changes }}
      updated-packages: ${{ steps.goupdate.outputs.updated-packages }}
      update-output: ${{ steps.goupdate.outputs.update-output }}
      pr-url: ${{ steps.pr.outputs.pr-url }}
      pr-number: ${{ steps.pr.outputs.pr-number }}

    steps:
      - name: Checkout main first
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Ensure target branch exists
        uses: ./.github/actions/_git-branch
        with:
          branch: ${{ env.UPDATE_TARGET_BRANCH }}
          base: main
          create-if-missing: 'true'
          push: 'true'

      - name: Setup Go
        uses: ./.github/actions/_go-setup
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Create update branch
        uses: ./.github/actions/_git-branch
        with:
          branch: ${{ env.UPDATE_BRANCH_NAME }}
          base: ${{ env.UPDATE_TARGET_BRANCH }}
          delete-remote: 'true'
          push: 'false'

      - name: Install goupdate
        uses: ./.github/actions/_goupdate-install

      - name: Apply updates
        id: goupdate
        uses: ./.github/actions/_goupdate-update
        with:
          update-type: ${{ needs.prepare.outputs.update-type }}
          exclude-packages: ${{ env.EXCLUDE_PACKAGES }}
          # System tests run via .goupdate.yml config (after_each mode)
          # No separate test step needed - goupdate handles testing

      - name: Generate messages
        id: messages
        if: steps.goupdate.outputs.has-changes == 'true'
        env:
          PR_TITLE_TEMPLATE: ${{ env.PR_TITLE }}
          COMMIT_MSG_TEMPLATE: ${{ env.COMMIT_MESSAGE }}
          UPDATE_TYPE: ${{ needs.prepare.outputs.update-type }}
        run: |
          DATE=$(date -u +%Y-%m-%d)
          # Capitalize first letter of update type
          TYPE=$(echo "$UPDATE_TYPE" | sed 's/\b\(.\)/\u\1/')

          # Generate PR title
          TITLE=$(echo "$PR_TITLE_TEMPLATE" | sed "s/{date}/$DATE/g" | sed "s/{type}/$TYPE/g")
          echo "pr_title=$TITLE" >> $GITHUB_OUTPUT

          # Generate commit message
          COMMIT_MSG=$(echo "$COMMIT_MSG_TEMPLATE" | sed "s/{date}/$DATE/g" | sed "s/{type}/$TYPE/g")
          echo "commit_msg=$COMMIT_MSG" >> $GITHUB_OUTPUT

      - name: Commit and push changes
        if: steps.goupdate.outputs.has-changes == 'true'
        env:
          UPDATE_OUTPUT: ${{ steps.goupdate.outputs.update-output }}
          COMMIT_MSG: ${{ steps.messages.outputs.commit_msg }}
        run: |
          # Extract package versions from update output (format: "package v1.0.0 → v2.0.0")
          FORMATTED_PKGS=$(echo "$UPDATE_OUTPUT" | grep -E "^\s+\S+\s+v[0-9]" | sed 's/^[[:space:]]*/- /' | head -20)

          git add go.mod go.sum
          git commit -m "$(cat <<EOF
          $COMMIT_MSG

          Updated packages:
          $FORMATTED_PKGS
          EOF
          )"
          git push -u origin "${{ env.UPDATE_BRANCH_NAME }}"

      - name: Generate GitHub App token
        id: app-token
        if: steps.goupdate.outputs.has-changes == 'true'
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GOUPDATE_APP_ID }}
          private-key: ${{ secrets.GOUPDATE_APP_PRIVATE_KEY }}

      - name: Format PR body
        id: pr-body
        if: steps.goupdate.outputs.has-changes == 'true'
        env:
          UPDATE_OUTPUT: ${{ steps.goupdate.outputs.update-output }}
        run: |
          {
            echo "body<<PR_BODY_EOF_7e3c1a"
            echo "## GoUpdate - Automated Dependency Update"
            echo ""
            echo '```'
            echo "$UPDATE_OUTPUT"
            echo '```'
            echo ""
            echo "---"
            echo "*Created by GoUpdate*"
            echo "PR_BODY_EOF_7e3c1a"
          } >> $GITHUB_OUTPUT

      - name: Create Pull Request
        id: pr
        if: steps.goupdate.outputs.has-changes == 'true'
        uses: ./.github/actions/_gh-pr
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          title: ${{ steps.messages.outputs.pr_title }}
          body: ${{ steps.pr-body.outputs.body }}
          base: ${{ env.UPDATE_TARGET_BRANCH }}
          head: ${{ env.UPDATE_BRANCH_NAME }}
          # Don't use GitHub's native auto-merge - it merges immediately if no branch protection
          # Instead, the merge-pr job waits for checks to pass and merges explicitly
          auto-merge: 'false'
          merge-method: 'squash'
          delete-branch: 'false'

      - name: Generate job summary
        if: steps.goupdate.outputs.has-changes == 'true'
        env:
          PR_URL: ${{ steps.pr.outputs.pr-url }}
          PR_NUMBER: ${{ steps.pr.outputs.pr-number }}
          UPDATE_BRANCH: ${{ env.UPDATE_BRANCH_NAME }}
          TARGET_BRANCH: ${{ env.UPDATE_TARGET_BRANCH }}
          UPDATE_OUTPUT: ${{ steps.goupdate.outputs.update-output }}
        run: |
          {
            echo "## GoUpdate - Apply Updates"
            echo ""
            echo "### PR Created"
            echo "- **PR:** [#$PR_NUMBER]($PR_URL)"
            echo "- **Branch:** \`$UPDATE_BRANCH\` → \`$TARGET_BRANCH\`"
            echo ""
            echo '```'
            echo "$UPDATE_OUTPUT"
            echo '```'
          } >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Wait for PR checks and merge
  # ============================================================================
  # This job waits for PR checks to pass then merges the PR.
  # The release workflow triggers automatically on push to stage branch.
  merge-pr:
    name: Merge PR
    needs: [prepare, apply-updates]
    if: |
      needs.prepare.outputs.auto-merge-updates == 'true' &&
      needs.apply-updates.outputs.pr-number != '' &&
      needs.apply-updates.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      merged: ${{ steps.wait-merge.outputs.merged }}
      checks-passed: ${{ steps.wait-merge.outputs.checks_passed }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GOUPDATE_APP_ID }}
          private-key: ${{ secrets.GOUPDATE_APP_PRIVATE_KEY }}

      - name: Wait for PR checks and merge
        id: wait-merge
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          PR_NUMBER: ${{ needs.apply-updates.outputs.pr-number }}
          REPO: ${{ github.repository }}
        run: |
          echo "Waiting for PR #$PR_NUMBER checks to pass before merging..."
          echo ""
          echo "This workflow waits for all CI checks to complete before merging."
          echo "This ensures PRs are never merged while checks are still running."
          echo ""
          echo "Using GitHub App token for authentication"
          echo ""

          # Poll for PR status (max ~7.5 minutes with 30s intervals)
          MAX_ATTEMPTS=15
          ATTEMPT=0
          CHECKS_COMPLETE=false

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "═══════════════════════════════════════════════════════════════"
            echo "Checking PR status (attempt $ATTEMPT/$MAX_ATTEMPTS)..."
            echo ""

            # Get PR state using REST API
            echo "Fetching PR #$PR_NUMBER data..."
            if ! PR_DATA=$(gh api "repos/$REPO/pulls/$PR_NUMBER" 2>&1); then
              echo ""
              echo "❌ Failed to fetch PR data: $PR_DATA"
              echo "Retrying in 30 seconds..."
              sleep 30
              continue
            fi

            STATE=$(echo "$PR_DATA" | jq -r '.state')
            MERGED=$(echo "$PR_DATA" | jq -r '.merged')
            HEAD_SHA=$(echo "$PR_DATA" | jq -r '.head.sha')

            echo "PR state: $STATE, merged: $MERGED, head SHA: ${HEAD_SHA:0:7}"

            # Check if already merged
            if [ "$MERGED" = "true" ]; then
              echo "✅ PR #$PR_NUMBER has been merged!"
              echo "merged=true" >> $GITHUB_OUTPUT
              echo "checks_passed=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            # Check if closed without merging
            if [ "$STATE" = "closed" ]; then
              echo "❌ PR #$PR_NUMBER was closed without merging"
              echo "merged=false" >> $GITHUB_OUTPUT
              echo "checks_passed=false" >> $GITHUB_OUTPUT
              exit 1
            fi

            # Check status of CI checks using REST API for check-runs
            if [ "$CHECKS_COMPLETE" = "false" ]; then
              echo ""
              echo "Fetching check runs for commit ${HEAD_SHA:0:7}..."
              if ! CHECKS_JSON=$(gh api "repos/$REPO/commits/$HEAD_SHA/check-runs" 2>&1); then
                echo ""
                echo "❌ Failed to fetch check runs: $CHECKS_JSON"
                echo "Retrying in 30 seconds..."
                sleep 30
                continue
              fi

              if echo "$CHECKS_JSON" | jq -e '.check_runs' > /dev/null 2>&1; then
                TOTAL_CHECKS=$(echo "$CHECKS_JSON" | jq '.total_count')
                PENDING=$(echo "$CHECKS_JSON" | jq '[.check_runs[] | select(.status != "completed")] | length')
                SUCCESSFUL=$(echo "$CHECKS_JSON" | jq '[.check_runs[] | select(.status == "completed" and (.conclusion == "success" or .conclusion == "skipped" or .conclusion == "neutral"))] | length')
                FAILED=$(echo "$CHECKS_JSON" | jq '[.check_runs[] | select(.status == "completed" and (.conclusion == "failure" or .conclusion == "cancelled" or .conclusion == "timed_out" or .conclusion == "startup_failure"))] | length')

                echo "Check runs: $TOTAL_CHECKS total, $PENDING pending, $SUCCESSFUL successful, $FAILED failed"

                # If any check failed, fail the workflow
                if [ "$FAILED" -gt 0 ]; then
                  echo ""
                  echo "❌ PR checks failed! Auto-merge will not proceed."
                  echo ""
                  echo "Failed checks:"
                  echo "$CHECKS_JSON" | jq -r '.check_runs[] | select(.status == "completed" and (.conclusion == "failure" or .conclusion == "cancelled" or .conclusion == "timed_out" or .conclusion == "startup_failure")) | "  - \(.name): \(.conclusion)"'
                  echo ""
                  echo "merged=false" >> $GITHUB_OUTPUT
                  echo "checks_passed=false" >> $GITHUB_OUTPUT
                  exit 1
                fi

                # If all checks completed successfully (none pending)
                if [ "$PENDING" -eq 0 ] && [ "$TOTAL_CHECKS" -gt 0 ]; then
                  echo ""
                  echo "✅ All PR checks passed!"
                  CHECKS_COMPLETE=true
                  echo "checks_passed=true" >> $GITHUB_OUTPUT

                  echo "Attempting to merge PR #$PR_NUMBER..."
                  MERGE_OUTPUT=$(gh pr merge "$PR_NUMBER" --squash --delete-branch 2>&1)
                  MERGE_EXIT_CODE=$?
                  if [ $MERGE_EXIT_CODE -eq 0 ]; then
                    echo "✅ PR #$PR_NUMBER merged successfully!"
                    echo "merged=true" >> $GITHUB_OUTPUT
                    exit 0
                  else
                    echo "Merge command returned exit code $MERGE_EXIT_CODE"
                    echo "Output: $MERGE_OUTPUT"
                    echo "Waiting for GitHub to complete merge..."
                    # Continue polling to confirm merge completed
                  fi
                elif [ "$TOTAL_CHECKS" -eq 0 ]; then
                  # No checks found, proceed with merge
                  echo ""
                  echo "No CI checks configured, proceeding with merge..."
                  CHECKS_COMPLETE=true
                  echo "checks_passed=true" >> $GITHUB_OUTPUT

                  echo "Attempting to merge PR #$PR_NUMBER..."
                  MERGE_OUTPUT=$(gh pr merge "$PR_NUMBER" --squash --delete-branch 2>&1)
                  MERGE_EXIT_CODE=$?
                  if [ $MERGE_EXIT_CODE -eq 0 ]; then
                    echo "✅ PR #$PR_NUMBER merged successfully!"
                    echo "merged=true" >> $GITHUB_OUTPUT
                    exit 0
                  else
                    echo "Merge failed with exit code $MERGE_EXIT_CODE: $MERGE_OUTPUT"
                  fi
                else
                  echo "Waiting for $PENDING checks to complete..."
                fi
              else
                echo ""
                echo "❌ Failed to parse check runs response"
                echo "Raw response (first 50 lines):"
                echo "---"
                echo "$CHECKS_JSON" | head -50
                echo "---"
                echo ""
                echo "Retrying..."
              fi
            fi

            # Wait 30 seconds before next check
            sleep 30
          done

          echo ""
          echo "❌ Timeout waiting for PR to merge (~7.5 minutes)"
          echo "merged=false" >> $GITHUB_OUTPUT
          echo "checks_passed=false" >> $GITHUB_OUTPUT
          exit 1

      - name: Generate job summary
        if: always()
        env:
          PR_URL: ${{ needs.apply-updates.outputs.pr-url }}
          PR_NUMBER: ${{ needs.apply-updates.outputs.pr-number }}
          MERGED: ${{ steps.wait-merge.outputs.merged }}
        run: |
          {
            echo "## GoUpdate - Merge PR"
            echo ""
            echo "- **PR:** [#$PR_NUMBER]($PR_URL)"
            if [ "$MERGED" = "true" ]; then
              echo "- **Status:** ✅ Merged"
            else
              echo "- **Status:** ❌ Not merged"
            fi
          } >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Summary
  # ============================================================================
  summary:
    name: Summary
    needs: [prepare, check-updates, apply-updates, merge-pr]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Generate summary
        env:
          EVENT: ${{ github.event_name }}
          MODE: ${{ github.event.inputs.mode }}
          HAS_UPDATES: ${{ needs.check-updates.outputs.has-updates }}
          CHECK_SUMMARY: ${{ needs.check-updates.outputs.summary }}
          UPDATE_OUTPUT: ${{ needs.apply-updates.outputs.update-output }}
          UPDATED_COUNT: ${{ needs.apply-updates.outputs.updated-count }}
          PR_URL: ${{ needs.apply-updates.outputs.pr-url }}
          PR_NUMBER: ${{ needs.apply-updates.outputs.pr-number }}
          CHECK_RESULT: ${{ needs.check-updates.result }}
          APPLY_RESULT: ${{ needs.apply-updates.result }}
          MERGE_RESULT: ${{ needs.merge-pr.result }}
          PR_MERGED: ${{ needs.merge-pr.outputs.merged }}
          AUTO_MERGE_ENABLED: ${{ needs.prepare.outputs.auto-merge-updates }}
        run: |
          echo "## GoUpdate - Auto Update Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** $EVENT" >> $GITHUB_STEP_SUMMARY
          if [ -n "$MODE" ]; then
            echo "**Mode:** $MODE" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # PR info if created
          if [ -n "$PR_URL" ]; then
            echo "### Pull Request" >> $GITHUB_STEP_SUMMARY
            echo "- **PR:** [#$PR_NUMBER]($PR_URL)" >> $GITHUB_STEP_SUMMARY
            if [ "$AUTO_MERGE_ENABLED" = "true" ]; then
              if [ "$PR_MERGED" = "true" ]; then
                echo "- **Status:** ✅ Merged (release workflow triggers automatically)" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "- **Status:** Awaiting manual review" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Show Check Updates summary
          if [ "$CHECK_RESULT" = "success" ] && [ -n "$CHECK_SUMMARY" ]; then
            echo "### Check Updates" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Update check complete: $CHECK_SUMMARY" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Show Apply Updates output
          if [ "$APPLY_RESULT" = "success" ] && [ -n "$UPDATE_OUTPUT" ]; then
            echo "### Apply Updates" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$UPDATE_OUTPUT" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

          # What happens next - show only when PR was merged
          if [ "$PR_MERGED" = "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### What Happens Next" >> $GITHUB_STEP_SUMMARY
            echo "The PR was merged to \`stage\`. A prerelease will be created for testing." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "When ready for stable release:" >> $GITHUB_STEP_SUMMARY
            echo "1. Merge \`stage\` → \`main\`" >> $GITHUB_STEP_SUMMARY
            echo "2. Create a release using one of these methods:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Option A: Command Line**" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "git tag v1.2.3 && git push origin v1.2.3" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Option B: GitHub UI**" >> $GITHUB_STEP_SUMMARY
            echo "1. Go to **Releases** → **Create a new release**" >> $GITHUB_STEP_SUMMARY
            echo "2. Click **Choose a tag** → type version (e.g., \`v1.2.3\`) → **Create new tag**" >> $GITHUB_STEP_SUMMARY
            echo "3. Set **Target** to \`main\` and check **Set as the latest release**" >> $GITHUB_STEP_SUMMARY
            echo "4. Click **Publish release**" >> $GITHUB_STEP_SUMMARY
          fi

# Goupdate Update Action
# Modular action for applying dependency updates
# Part of the modular goupdate action suite

name: 'Goupdate Update'
description: 'Apply dependency updates'

inputs:
  working-directory:
    description: 'Working directory containing go.mod'
    required: false
    default: '.'
  update-type:
    description: 'Type of updates: none (use constraints), patch, minor, or major (includes all)'
    required: false
    default: 'minor'
  exclude-packages:
    description: 'Packages to skip (comma-separated)'
    required: false
    default: ''
  system-test-mode:
    description: 'System test run mode: after_each, after_all, or none'
    required: false
    default: ''
  verbose:
    description: 'Enable verbose output'
    required: false
    default: 'false'

outputs:
  updated:
    description: 'Whether any packages were updated'
    value: ${{ steps.update.outputs.updated }}
  has-changes:
    description: 'Whether go.mod was modified (alias for updated)'
    value: ${{ steps.update.outputs.updated }}
  updated-packages:
    description: 'Space-separated list of updated packages'
    value: ${{ steps.update.outputs.updated_packages }}
  updated-count:
    description: 'Number of packages updated'
    value: ${{ steps.update.outputs.updated_count }}
  update-output:
    description: 'Raw output from goupdate update command'
    value: ${{ steps.update.outputs.update_output }}
  exit-code:
    description: 'Exit code from goupdate update command'
    value: ${{ steps.update.outputs.exit_code }}

runs:
  using: 'composite'
  steps:
    - name: Apply updates
      id: update
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        UPDATE_TYPE: ${{ inputs.update-type }}
        EXCLUDE: ${{ inputs.exclude-packages }}
        SYSTEM_TEST_MODE: ${{ inputs.system-test-mode }}
        VERBOSE: ${{ inputs.verbose }}
      run: |
        # Build update type flag
        UPDATE_FLAG=""
        case "$UPDATE_TYPE" in
          patch) UPDATE_FLAG="--patch" ;;
          minor) UPDATE_FLAG="--minor" ;;
          major) UPDATE_FLAG="--major" ;;
          all)   UPDATE_FLAG="--major" ;;  # 'all' is alias for major
          none)  UPDATE_FLAG="" ;;
        esac

        # Note: Package exclusion is configured via .goupdate.yml, not CLI flags
        # The exclude-packages input is kept for documentation but doesn't filter directly
        # To exclude packages, add them to your .goupdate.yml under rules.<rule>.exclude

        # Build system test flag
        TEST_FLAG=""
        if [[ -n "$SYSTEM_TEST_MODE" ]]; then
          TEST_FLAG="--system-test-mode=$SYSTEM_TEST_MODE"
        fi

        # Build verbose flag
        VERBOSE_FLAG=""
        if [[ "$VERBOSE" == "true" ]]; then
          VERBOSE_FLAG="-v"
        fi

        # Run update with continue-on-fail to see all errors
        # Stream output live while capturing to file for later parsing
        # This ensures developers see progress in real-time
        OUTPUT_FILE=$(mktemp)
        STDERR_FILE=$(mktemp)
        set +e
        goupdate update -r mod $UPDATE_FLAG $TEST_FLAG $VERBOSE_FLAG --continue-on-fail -y 2>"$STDERR_FILE" | tee "$OUTPUT_FILE"
        EXIT_CODE=${PIPESTATUS[0]}
        set -e
        OUTPUT=$(cat "$OUTPUT_FILE")
        rm -f "$OUTPUT_FILE"

        # Show any stderr
        if [[ -s "$STDERR_FILE" ]]; then
          cat "$STDERR_FILE" >&2
        fi
        rm -f "$STDERR_FILE"

        # If command failed and verbose was not enabled, re-run with verbose for debugging
        if [[ "$EXIT_CODE" -ne 0 && "$VERBOSE" != "true" ]]; then
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸ” VERBOSE DEBUG OUTPUT (exit code: $EXIT_CODE)"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "Command failed with exit code $EXIT_CODE. Re-running with verbose mode..."
          echo "Exit codes: 0=success, 1=partial failure, 2=complete failure, 3=config error"
          echo ""
          goupdate update -r mod $UPDATE_FLAG $TEST_FLAG --verbose --continue-on-fail -y --dry-run 2>&1 || true
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "End of verbose debug output"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        fi

        # Parse updated packages from output (space-separated)
        # Note: grep returns exit code 1 if no matches, so we use || true to prevent script exit
        UPDATED_PACKAGES=$(echo "$OUTPUT" | grep -E "ðŸŸ¢ Updated" | awk '{print $NF}' | tr '\n' ' ' | sed 's/ $//' || true)
        UPDATED_COUNT=$(echo "$UPDATED_PACKAGES" | wc -w | tr -d ' ')

        # Determine if updates were applied
        UPDATED="false"
        if ! git diff --quiet go.mod 2>/dev/null; then
          UPDATED="true"
        fi

        echo "updated=$UPDATED" >> "$GITHUB_OUTPUT"
        echo "updated_packages=$UPDATED_PACKAGES" >> "$GITHUB_OUTPUT"
        echo "updated_count=$UPDATED_COUNT" >> "$GITHUB_OUTPUT"
        echo "exit_code=$EXIT_CODE" >> "$GITHUB_OUTPUT"

        # Store output for summaries
        {
          echo "update_output<<EOF"
          echo "$OUTPUT"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

        if [[ "$EXIT_CODE" -ne 0 ]]; then
          echo "::warning::goupdate update exited with code $EXIT_CODE"
        fi

        exit $EXIT_CODE
